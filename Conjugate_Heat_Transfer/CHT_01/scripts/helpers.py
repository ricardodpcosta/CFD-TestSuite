#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
===============================================================================
CFD-BenchLab | Helpers
===============================================================================

Description:
    Utility functions for code generation in multiple programming languages
    (C++, Fortran, Octave/Matlab, and Python). Includes code formatting and
    line-wrapping helpers to keep generated source code within a configurable
    line width.

    This module is intended to be imported by the main code generation script
    (generate_code.py).

Author:
    Ricardo Costa (rcosta@dep.uminho.pt)

License:
    MIT License (see LICENSE file for details)

Repository:
    https://github.com/ricardodpcosta/CFD-TestSuite

Dependencies:
    pip install sympy

Usage:
    from helpers import *
===============================================================================
"""

# Import modules
import re
import textwrap
import sympy

# Import specific printers
try:
    from sympy.printing.c import ccode
    from sympy.printing.fortran import fcode
    from sympy.printing.octave import octave_code
    from sympy.printing.pycode import pycode
except Exception:
    raise RuntimeError("Required SymPy printers not available. Ensure sympy >= 1.6 is installed.")

# Write contens to file
def write_file(path, contents):
    with open(path, "w", encoding="utf-8") as fh:
        fh.write(contents)
    print("Wrote", path)

# Write C code
def write_c_function(name, expr, args):
    arglist = ", ".join(f"double {nm}" for (_, nm) in args)
    cexpr = ccode(sympy.simplify(sympy.trigsimp(expr)))
    cexpr = "\n".join(wrap_cpp_line(f"return {cexpr}", width=72, indent="            "))
    body = textwrap.dedent(f"""
    // Auto-generated by generate_code.py
    double {name}({arglist}) {{
        {cexpr};
    }}
    """).strip()
    return body

# Write Fortran code
def write_fortran_function(name, expr, args):
    argnames = ", ".join(nm for (_, nm) in args)
    decl_lines = [f"real(8), intent(in) :: {nm}" for (_, nm) in args]
    decl = "\n".join((line if i == 0 else "        " + line) for i, line in enumerate(decl_lines))
    fexpr = fcode(sympy.simplify(sympy.trigsimp(expr)), assign_to=None, source_format='free')
    fexpr = fexpr.replace(" &\n", "")
    fexpr = re.sub(r' {2,}', ' ', fexpr)
    fexpr = fexpr.strip()
    fexpr = "\n".join(wrap_fortran_line(f"res = {fexpr}", width=72, indent="            "))
    body = textwrap.dedent(f"""
    ! Auto-generated by generate_code.py
    function {name}({argnames}) result(res)
        {decl}
        real(8) :: res
        {fexpr}
    end function {name}
    """).strip()
    return body

# Write Matlab code
def write_octave_function(name, expr, args):
    arglist = ", ".join(nm for (_, nm) in args)
    mexpr = octave_code(sympy.simplify(sympy.trigsimp(expr)))
    mexpr = "\n".join(wrap_octave_line(f"res = {mexpr}", width=72, indent="            "))
    body = textwrap.dedent(f"""
    % Auto-generated by generate_code.py
    function res = {name}({arglist})
        {mexpr};
    end
    """).strip()
    return body

# Write Python code
def write_python_function(name, expr, args):
    arglist = ", ".join(nm for (_, nm) in args)
    pexpr = pycode(sympy.simplify(sympy.trigsimp(expr)))
    pexpr = "\n".join(wrap_python_line(f"return {pexpr}", width=72, indent="            "))
    body = textwrap.dedent(f"""
    # Auto-generated by generate_code.py
    import numpy as _np
    def {name}({arglist}):
        {pexpr}
    """).strip()
    return body

# Wrap C++ code
def wrap_cpp_line(line, width=72, indent=""):
    """
    Wrap a C++ code line to a given width, breaking at operators (+, -, *, /) or spaces.
    Adds a trailing backslash '\' for line continuation.
    Indents continuation lines with the given indent string.
    """
    if len(line) <= width:
        return [line]
    parts = []
    while len(line) > width:
        break_pos = max(line.rfind(op, 0, width) for op in ['+', '-', '*', '/'])
        if break_pos == -1:
            break_pos = line.rfind(' ', 0, width)
        if break_pos == -1:
            break_pos = width
        if break_pos < len("return "):
            break_pos = width
        parts.append(line[:break_pos].rstrip() + " \\")
        line = indent + line[break_pos:].lstrip()
    parts.append(line)
    return parts

# Wrap Fortran code
def wrap_fortran_line(line, width=72, indent=""):
    """
    Wrap a Fortran code line to a given width, breaking at operators (+, -, *, /) or spaces.
    Adds a trailing ampersand '&' for line continuation.
    Indents continuation lines with the given indent string.
    """
    if len(line) <= width:
        return [line]
    parts = []
    while len(line) > width:
        break_pos = max(line.rfind(op, 0, width) for op in ['+', '-', '*', '/'])
        if break_pos == -1:
            break_pos = line.rfind(' ', 0, width)
        if break_pos == -1:
            break_pos = width
        if break_pos < len("res = "):
            break_pos = width
        parts.append(line[:break_pos].rstrip() + " &")
        line = indent + line[break_pos:].lstrip()
    parts.append(line)
    return parts

# Wrap Octave code
def wrap_octave_line(line, width=72, indent=""):
    """
    Wrap a Octave code line to a given width, breaking at operators (+, -, *, /) or spaces.
    Adds a trailing ellipsis '...' for line continuation.
    Indents continuation lines with the given indent string.
    """
    if len(line) <= width:
        return [line]
    parts = []
    while len(line) > width:
        break_pos = max(line.rfind(op, 0, width) for op in ['+', '-', '*', '/'])
        if break_pos == -1:
            break_pos = line.rfind(' ', 0, width)
        if break_pos == -1:
            break_pos = width
        if break_pos < len("res = "):
            break_pos = width
        parts.append(line[:break_pos].rstrip() + " ...")
        line = indent + line[break_pos:].lstrip()
    parts.append(line)
    return parts

# Wrap Python code
def wrap_python_line(line, width=72, indent=""):
    """
    Wrap a Python code line to a given width, breaking at operators (+, -, *, /) or spaces.
    Adds a trailing backslash '\' for line continuation.
    Indents continuation lines with the given indent string.
    """
    if len(line) <= width:
        return [line]
    parts = []
    while len(line) > width:
        break_pos = max(line.rfind(op, 0, width) for op in ['+', '-', '*', '/'])
        if break_pos == -1:
            break_pos = line.rfind(' ', 0, width)
        if break_pos == -1:
            break_pos = width
        if break_pos < len("return "):
            break_pos = width
        parts.append(line[:break_pos].rstrip() + " \\")
        line = indent + line[break_pos:].lstrip()
    parts.append(line)
    return parts
