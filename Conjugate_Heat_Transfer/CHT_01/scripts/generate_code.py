#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
===============================================================================
CFD-BenchLab | CHT_01 | Code Generator
===============================================================================

Description:
    Generates code for the symbolic expressions in multiple target languages:
    C/C++, Fortran, Octave/Matlab, and Python.
    Outputs one file per expression/language.

Author:
    Ricardo Costa (rcosta@dep.uminho.pt)

License:
    MIT License (see LICENSE file for details)

Repository:
    https://github.com/ricardodpcosta/CFD-TestSuite

Dependencies:
    Python (version => 3.9)
    Sympy (version >= 1.6)

Usage:
    python generate_code.py
===============================================================================
"""

# Import modules
import os
import sympy
from helpers import *

# ----------------------------------------
# Define symbolic pariables
# ----------------------------------------

# Variable parameters
rA, rAB, rB = sympy.symbols("rA rAB rB", positive=True)
kA, kB = sympy.symbols("kA kB", positive=True)
nA, nB = sympy.symbols("nA nB", real=True)
wA, wB = sympy.symbols("wA wB", real=True)

# Solution parameters
aA, bA, aB, bB = sympy.symbols("aA bA aB bB", real=True)

# Coordinate system
r, theta = sympy.symbols("r theta", real=True, positive=True)
x, y = sympy.symbols("x y", real=True, positive=False)

# ----------------------------------------
# Define manufactured solutions
# ----------------------------------------

# Manufactured solutions
phiA = (aA * sympy.log(r) + bA) * sympy.cos(nA * theta)
phiB = (aB * sympy.log(r) + bB) * sympy.cos(nB * theta)

# ----------------------------------------
# Define velocity fields
# ----------------------------------------

# Velocity fields
uA_r = 0
uA_theta = wA*r
uA = [uA_r, uA_theta]
uB_r = 0
uB_theta = wB*r
uB = [uB_r, uB_theta]

# ----------------------------------------
# Compute solution parameters
# ----------------------------------------

# Dirichlet boundary conditions
eq1 = sympy.Eq(phiA.subs(r, rA), sympy.cos(nA * theta))
eq2 = sympy.Eq(phiB.subs(r, rB), 0)

# Solution continuity at interface
eq3 = sympy.Eq(phiA.subs(r, rAB), phiB.subs(r, rAB))

# Flux conservation at interface
dphiA_dr = sympy.diff(phiA, r)
dphiB_dr = sympy.diff(phiB, r)
eq4 = sympy.Eq(-kA * dphiA_dr.subs(r, rAB), kB * dphiB_dr.subs(r, rAB))

# Solve for coefficients
sol = sympy.solve([eq1, eq2, eq3, eq4], (aA, bA, aB, bB), dict=True)
if not sol:
    raise RuntimeError("Could not solve for coefficients symbolically.")
sol = sol[0]

# Substitute into manufactured solutions
# phiA = sympy.simplify(phiA.subs(sol))
# phiB = sympy.simplify(phiB.subs(sol))

# ----------------------------------------
# Compute source terms
# ----------------------------------------

# Diffusive terms
diffA = (1/r) * sympy.diff(r * sympy.diff(phiA, r), r) + (1/r**2) * sympy.diff(sympy.diff(phiA, theta), theta)
diffB = (1/r) * sympy.diff(r * sympy.diff(phiB, r), r) + (1/r**2) * sympy.diff(sympy.diff(phiB, theta), theta)

# Convective terms
convA = (uA_theta / r) * sympy.diff(phiA, theta)
convB = (uB_theta / r) * sympy.diff(phiB, theta)

# Source-terms
fA = sympy.simplify(convA - kA * diffA)
fB = sympy.simplify(convB - kB * diffB)

# ----------------------------------------
# Write symbolic expressions
# ----------------------------------------

# Output directory
outdir = "../symbolic"
os.makedirs(outdir, exist_ok=True)

# Coordinate system conversion
r = sympy.sqrt(x**2 + y**2)
theta = sympy.atan2(y,x)

# Variable parameters values
rA = 1.0
rAB = 0.75
rB = 0.5
kA = 2.0
kB = 1.0
nA = 4
nB = 4
wA = 1.0
wB = -1.0

# Arguments list
arg_list = [("x", x), ("y", y)]

# Variables list
var_list = [("rAB", rAB), ("rB", rB), ("kA", kA), ("kB", kB),
        ("nA", nA), ("nB", nB), ("wA", wA), ("wB", wB)]

# Parameters list
parA_list = [("r", r), ("theta", theta), ("aA", sol[aA]), ("bA", sol[bA])]
parB_list = [("r", r), ("theta", theta), ("aB", sol[aB]), ("bB", sol[bB])]

# Functions list
func_list = [("phiA", phiA, arg_list, parA_list), ("phiB", phiB, arg_list, parB_list),
                ("fA", fA, arg_list, parA_list), ("fB", fB, arg_list, parB_list)]

# ----------------------------------------
# Generate code
# ----------------------------------------

# Generate implementations C/C++
contents = ["// Auto-generated by generate_code.py"]
contents.append(write_cpp_variables(var_list))
for (name, expr, arg_list, par_list) in func_list:
    try:
        code = write_cpp_function(name, expr, arg_list, par_list)
        contents.append(code)
    except Exception as e:
        print("C/C++ generation failed for", name, ":", e)
contents = "\n\n".join(contents) + "\n"
write_file(os.path.join(outdir, "cht_01.cpp"), contents)

# Generate implementations Fortran
contents = ["! Auto-generated by generate_code.py"]
contents.append(write_fortran_variables(var_list))
for (name, expr, arg_list, par_list) in func_list:
    try:
        code = write_fortran_function(name, expr, arg_list, par_list)
        contents.append(code)
    except Exception as e:
        print("Fortran generation failed for", name, ":", e)
contents = "\n\n".join(contents) + "\n"
write_file(os.path.join(outdir, "cht_01.f90"), contents)

# Generate implementations Octave/Matlab
contents = ["% Auto-generated by generate_code.py"]
contents.append(write_octave_variables(var_list))
for (name, expr, arg_list, par_list) in func_list:
    try:
        code = write_octave_function(name, expr, arg_list, par_list)
        contents.append(code)
    except Exception as e:
        print("Octave/Matlab generation failed for", name, ":", e)
contents = "\n\n".join(contents) + "\n"
write_file(os.path.join(outdir, "cht_01.m"), contents)

# Generate implementations Python
contents = ["# Auto-generated by generate_code.py"]
contents.append(write_python_variables(var_list))
for (name, expr, arg_list, par_list) in func_list:
    try:
        code = write_python_function(name, expr, arg_list, par_list)
        contents.append(code)
    except Exception as e:
        print("Python generation failed for", name, ":", e)
contents = "\n\n".join(contents) + "\n"
write_file(os.path.join(outdir, "cht_01.py"), contents)

print("\nGeneration complete. Files are in:", outdir)
